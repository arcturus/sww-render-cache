{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","index.js","lib/RenderCache.js","node_modules/threads/index.js","node_modules/threads/lib/child-thread.js","node_modules/threads/lib/client/index.js","node_modules/threads/lib/client/stream.js","node_modules/threads/lib/emitter.js","node_modules/threads/lib/manager.js","node_modules/threads/lib/messenger.js","node_modules/threads/lib/service/index.js","node_modules/threads/lib/service/stream.js","node_modules/threads/lib/thread-global.js","node_modules/threads/lib/utils.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"RenderCache.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var RenderCache = require('./lib/RenderCache.js');\n\nself.RenderCache = RenderCache;\n","/* globals caches, Request, Response, Promise */\n'use strict';\n\nvar threads = require('threads');\n\n/**\n * Constructor, we will pass a cache name to store the render cache content\n * inside Will create a threadjs server to listen to commands\n * @param cacheName Name of the cache to store the content\n * @constructor\n */\nfunction RenderCache(cacheName) {\n  this.cacheName = cacheName;\n  this.createService();\n}\n\n/**\n * Utility method to return a reference to the cache handled by this\n * middleware\n * @returns {Promise} Promise resolved with the cache reference.\n * @private\n */\nRenderCache.prototype._openCache = function _openCache() {\n  return caches.open(this.cacheName);\n};\n\n/**\n * Respond to fetch event, check internally if our cache has a matching\n * url.\n * @param request (Request) the requested url\n * @returns {Promise} Promise resolved with the cached element or null\n * if this cache doesn't contain anything for the requested url.\n */\nRenderCache.prototype.onFetch = function onFetch(request) {\n  return this._openCache().then(function(cache) {\n    return cache.match(request).then(function(response) {\n      return response !== null ? Promise.resolve(response) : null;\n    });\n  });\n};\n\n/**\n * Build the service explicitly adding methods that will be handled\n * by this middleware.\n */\nRenderCache.prototype.createService = function createService() {\n  this.service = threads.service(this.getServiceName());\n  // Append the contract\n  this.service.contract({\n    methods: {\n      listContent: [],\n      evict: [],\n      remove: ['string'],\n      add: ['string', 'object', 'object'],\n      addHtml: ['string', 'string'],\n      addPng: ['string', 'blob']\n    }\n  });\n  // Add the methods\n  ['listContent', 'evict', 'remove', 'add', 'addHtml', 'addPng'].forEach((\n    function(methodName) {\n    this.service.method(methodName, (this[methodName]).bind(this));\n  }).bind(this));\n};\n\n/**\n * Returns the name of the service. Right now this method is dummy,\n * but we can add any extra logic to know this name.\n */\nRenderCache.prototype.getServiceName = function getServiceName() {\n  return 'RenderCacheService';\n};\n\n// Below you can find the implementation of the methods that\n// the threadjs server exposes\n\n/**\n * List all the keys, content by url, of the cache.\n * @returns {*} (Promise) Promise containing the list of keys on the cache.\n */\nRenderCache.prototype.listContent = function listContent() {\n  return this._openCache().then(function(cache) {\n    return cache.keys();\n  });\n};\n\n/**\n * Clean the cache.\n * @returns {*} (Promise) Promise that resolves to true if cache is cleaned.\n */\nRenderCache.prototype.evict = function evict() {\n  return this._openCache().then(function(cache) {\n    return cache.delete();\n  });\n};\n\n/**\n * Delete an element of this cache. No matter what kind of request, it will\n * remove the resource.\n * @param url (string) resource url\n */\nRenderCache.prototype.remove = function remove(url) {\n  return this._openCache().then(function(cache) {\n    return cache.delete(new Request(url),\n      {ignoreSearch: true, ignoreMethod: true});\n  });\n};\n\n/**\n * Save any kind of content in the cache. User needs to specify the headers\n * to return later a valid response.\n * @param url (string) url to be saved\n * @param headers (object) contains the keys and values headers\n * @param content (mixed) depending on the content string, blob, etc.\n * @returns {*} (Promise) Promise to be resolved to true if correct.\n */\nRenderCache.prototype.add = function add(url, headers, content) {\n  return this._openCache().then(function(cache) {\n    return cache.put(new Request(url), new Response(content, {\n      headers: headers\n    }));\n  });\n};\n\n/**\n * Utility method to save an html document. It add extra information\n * like headers.\n * @param url (string) Url to save\n * @param content (string) Content to be saved\n * @returns {*} (Promise) Promise resolved to true if correct.\n */\nRenderCache.prototype.addHtml = function addHtml(url, content) {\n  return this.add(url, {\n    'Content-Type': 'text/html'\n  }, content);\n};\n\n/**\n * Utility method to save png images in this cache.\n * @param url The url of the resource\n * @param content (blob) a blob containing the resource\n * @returns {*} (Promise) Promise resovled to true if correct.\n */\nRenderCache.prototype.addPng = function addPng(url, content) {\n  return this.add(url, {\n    'Content-Type': 'image/png'\n  }, content);\n};\n\nRenderCache.prototype.version = '0.0.1';\n\nmodule.exports = RenderCache;\n","\nmodule.exports = {\n  create: require('./lib/child-thread'),\n  manager: require('./lib/manager'),\n  service: require('./lib/service'),\n  client: require('./lib/client')\n};\n","'use strict';\n\n/**\n * Dependencies\n */\n\nvar Messenger = require('./messenger');\nvar emitter = require('./emitter');\nvar utils = require('./utils');\n\n/**\n * Exports\n */\n\nmodule.exports = ChildThread;\n\n/**\n * Mini debugger\n *\n * @type {Function}\n */\n\nvar debug = 1 ? console.log.bind(console, '[ChildThread]') : function() {};\n\n/**\n * Extends `Emitter`\n */\n\nChildThread.prototype = Object.create(emitter.prototype);\n\n/**\n * Wraps a reference to a 'thread'.\n *\n * Providing a means to send/recieve\n * messages to/from a 'thread'.\n *\n * Params:\n *\n *   - `src` {String}\n *   - `type` {String} ['window'|'worker'|'sharedworker']\n *   - `target` {HTMLIframeElement|Worker|SharedWorker}\n *   - `parentNode` {HTMLElement}\n *\n * @param {Object} params\n */\n\nfunction ChildThread(params) {\n  if (!(this instanceof ChildThread)) return new ChildThread(params);\n  if (!knownType(params.type)) throw error(3, params.type);\n  this.id = utils.uuid();\n  this.src = params.src;\n  this.type = params.type;\n  this.parentNode = params.parentNode;\n  this.target = params.target ||  this.createTarget();\n  this.threadId = undefined;\n  this.services = {};\n\n  this.onmessage = this.onmessage.bind(this);\n  this.messenger = new Messenger(this.id, '[ChildThread]')\n    .handle('redundant', this.onredundant, this)\n    .handle('serviceready', this.onserviceready, this);\n\n  this.listen();\n  this.ready = this.checkReady();\n  debug('initialized', this.type);\n}\n\n/**\n * Creates the actual target thread.\n *\n * @return {Worker|SharedWorker|HTMLIframeElement}\n */\n\nChildThread.prototype.createTarget = function() {\n  debug('create process');\n  switch(this.type) {\n    case 'worker': return new Worker(this.src);\n    case 'sharedworker': return new SharedWorker(this.src);\n    case 'window':\n      if (utils.env() !== 'window') throw error(1);\n      var iframe = document.createElement('iframe');\n      (this.parentNode || document.body).appendChild(iframe);\n      iframe.src = this.src;\n      return iframe;\n  }\n};\n\n/**\n * Attempts to get `Service` info from the target.\n *\n * @param  {String} name\n * @return {Object}\n */\n\nChildThread.prototype.getService = function(name) {\n  debug('get service when ready...', name);\n  return this.ready.then(function() {\n    return this._getService(name);\n  }.bind(this));\n};\n\n/**\n * Returns the given service object,\n * or waits for a matching Service\n * to become ready.\n *\n * REVIEW: This logic could be bundled\n * inside `ThreadGlobal` and we could\n * instead send a 'getService' request\n * message to the thread when we don't\n * yet know about the asked `Service`.\n *\n * This would have to be done after 'ready'.\n *\n * @param  {String} name\n * @return {Promise}\n */\n\nChildThread.prototype._getService = function(name) {\n  debug('get service', name);\n  var service = this.services[name];\n\n  if (service) {\n    debug('service already known');\n    return Promise.resolve(service);\n  }\n\n  var deferred = utils.deferred();\n  var self = this;\n\n  this.on('serviceready', onServiceReady);\n\n  function onServiceReady(service) {\n    if (service.name !== name) return;\n    debug('service ready', service.name);\n    self.off('serviceready', onServiceReady);\n    clearTimeout(timeout);\n    deferred.resolve(service);\n  }\n\n  // Request will timeout when no service of\n  // this name becomes ready within 4sec\n  var timeout = setTimeout(function() {\n    self.off('serviceready', onServiceReady);\n    deferred.reject(error(2, name));\n  }, 2000);\n\n  return deferred.promise;\n};\n\n/**\n * Checks if the target's `ThreadGlobal` is 'ready'.\n *\n * We have a race of two approaches:\n *\n * 1. We attempt to ping the thread.\n * 2. We wait for the 'threadready' message.\n *\n * Approach 1. will occur when the thread is\n * already alive and kicking. Approach 2. will\n * occur when the thread is brand new and not\n * yet running.\n *\n * @return {Promise}\n */\n\nChildThread.prototype.checkReady = function() {\n  debug('check ready');\n  var deferred = utils.deferred();\n  var called = 0;\n  var self = this;\n\n  this.messenger.request(this, { type: 'ping' }).then(ready); // 1.\n  this.messenger.handle('threadready', ready); // 2.\n\n  function ready(thread) {\n    if (called++) return;\n    debug('thread ready', thread);\n    self.messenger.unhandle('threadready');\n    self.threadId = thread.id;\n    self.services = thread.services;\n    deferred.resolve();\n  }\n\n  return deferred.promise;\n};\n\n/**\n * Abstracted .postMessage() to send\n * a message directly to the target.\n *\n * @param  {Object} message\n * @private\n */\n\nChildThread.prototype.postMessage = function(message) {\n  debug('post message', message);\n  switch(this.type) {\n    case 'worker': this.target.postMessage(message); break;\n    case 'sharedworker': this.target.port.postMessage(message); break;\n    case 'window':\n      if (!this.target.contentWindow) return;\n      this.target.contentWindow.postMessage(message, '*');\n  }\n};\n\n/**\n * Listen for messages that *may*\n * have come from the target thread.\n *\n * For iframe targets we can't listen\n * directly to the target, so we have\n * to listen on `window`. We depend\n * on `Messenger` to filter out any\n * stuff that not intended for us.\n *\n * @private\n */\n\nChildThread.prototype.listen = function() {\n  debug('listen (%s)', this.type);\n  switch(this.type) {\n    case 'worker':\n      this.target.addEventListener('message', this.onmessage);\n      break;\n    case 'sharedworker':\n      this.target.port.start();\n      this.target.port.addEventListener('message', this.onmessage);\n      break;\n    case 'window':\n      addEventListener('message', this.onmessage);\n  }\n};\n\n/**\n * Remove target message listener.\n *\n * @private\n */\n\nChildThread.prototype.unlisten = function() {\n  switch(this.type) {\n    case 'worker':\n      this.target.removeEventListener('message', this.onmessage);\n      break;\n    case 'sharedworker':\n      this.target.port.close();\n      this.target.port.removeEventListener('message', this.onmessage);\n      break;\n    case 'window':\n      removeEventListener('message', this.onmessage);\n  }\n};\n\n/**\n * Parses raw message event through\n * `Messenger` and re-emits a public\n * 'message' event so that `Clients`\n * can listen for messages that may\n * be explicitly targeted at them.\n *\n * @param  {Event} e\n * @private\n */\n\nChildThread.prototype.onmessage = function(e) {\n  if (!this.fromTarget(e)) return;\n  debug('on message', e.data.data);\n  this.messenger.parse(e);\n  this.emit('message', e);\n};\n\n/**\n * Check if message event comes from target.\n *\n * @param  {Event} e\n * @return {Boolean}\n */\n\nChildThread.prototype.fromTarget = function(e) {\n  return e.target === this.target\n    || this.target.contentWindow === e.source\n    || e.target === this.target.port;\n};\n\n/**\n * Whenever a `Sevice` becomes 'ready'\n * inside the target, a message will\n * be sent to us.\n *\n * We keep a list of known running `Services`.\n *\n * We emit the 'serviceready' event so that\n * the `.getService()` method knows when\n * to callback.\n *\n * TODO: Remove services from this list\n * if they are destroyed within the target\n * thread.\n *\n * @param  {Object} service\n */\n\nChildThread.prototype.onserviceready = function(service) {\n  debug('on service ready', service);\n  this.services[service.name] = service;\n  this.emit('serviceready', service);\n};\n\n/**\n * The target will send a 'redundant'\n * message to the outside world once\n * it's service have no more Clients.\n *\n * We emit this event so that a `Manager`\n * or whomever created the `ChildThread`\n * can destroy it.\n *\n * @private\n */\n\nChildThread.prototype.onredundant = function() {\n  debug('redundant');\n  this.emit('redundant');\n};\n\n/**\n * Destroy the Thread.\n *\n * We unbind *all* listeners that may have\n * attached themselves to events emitted\n * from this object.\n *\n * @public\n */\n\nChildThread.prototype.destroy = function() {\n  this.unlisten();\n  this.destroyTarget();\n  this.off();\n};\n\n/**\n * Destroy the actual thread instance.\n *\n * @private\n */\n\nChildThread.prototype.destroyTarget = function() {\n  debug('destroy thread (%s)');\n\n  switch(this.type) {\n    case 'worker': this.target.terminate(); break;\n    case 'sharedworker': this.target.port.close(); break;\n    case 'window': this.target.remove(); break;\n  }\n\n  // If we don't clear the reference\n  // the browser can't always cleanup.\n  // Sometimes `SharedWorkers` don't die.\n  delete this.target;\n};\n\n/**\n * Utils\n */\n\n/**\n * Checks if given type is known.\n *\n * @param  {String} type\n * @return {Boolean}\n */\n\nfunction knownType(type) {\n  return !!~[\n    'window',\n    'worker',\n    'sharedworker'\n  ].indexOf(type);\n}\n\n/**\n * Handy `Error` factory.\n *\n * @param  {Number} id\n * @return {String}\n */\n\nfunction error(id) {\n  var args = [].slice.call(arguments, 1);\n  return new Error({\n    1: 'iframes can\\'t be spawned from workers',\n    2: 'Request to get service \"' + args[0] + '\" timed out',\n    3: 'type \"' + args[0] + '\" not recognized, must be: ' +\n      '\\'window\\', \\'worker\\' or \\'sharedworker\\''\n  }[id]);\n}\n","'use strict';\n\n/**\n * Dependencies\n */\n\nvar thread = require('../thread-global');\nvar ClientStream = require('./stream');\nvar Messenger = require('../messenger');\nvar Emitter = require('../emitter');\nvar utils = require('../utils');\n\n/**\n * Exports\n */\n\nmodule.exports = Client;\n\n/**\n * Global 'manager' channel\n *\n * @type {BroadcastChannel}\n */\n\nvar manager = new BroadcastChannel('threadsmanager');\n\n/**\n * Simple logger\n *\n * @type {Function}\n */\n\nvar debug = 1 ? console.log.bind(console, '[Client]') : function() {};\n\n/**\n * Extends `Emitter`\n */\n\nClient.prototype = Object.create(Emitter.prototype);\n\n/**\n * Initialize a new `Client`.\n *\n * @param {String} service The service name\n * @param {Object} options\n * @param {ChildThread} options.thread\n * @param {Object} options.contract\n */\n\nfunction Client(service, options) {\n  if (!(this instanceof Client)) return new Client(service, options);\n  this.contract = options && options.contract;\n  this.thread = options && options.thread;\n\n  this.id = utils.uuid();\n  this._activeStreams = {};\n  this._connected = false;\n\n  this.service = {\n    channel: undefined,\n    name: service,\n    id: undefined\n  };\n\n  this.messenger = new Messenger(this.id, 'client')\n    .handle('streamevent', this.onstreamevent, this)\n    .handle('broadcast', this.onbroadcast, this);\n\n  this.connect();\n  debug('initialized', service);\n}\n\n/**\n * Attempt to connect the `Client`\n * with its service.\n *\n * @return {Promise}\n * @public\n */\n\nClient.prototype.connect = function() {\n  if (this.connected) return this.connected;\n  debug('connecting...');\n  var self = this;\n\n  // Create a pipe ready for the\n  // service to send messages down\n  this.service.channel = new BroadcastChannel(this.id);\n  this.service.channel.onmessage = this.messenger.parse;\n\n  // If the client has a handle on the\n  // thread we can connect to it directly,\n  // else we go through the manager proxy.\n  this.connected = this.thread\n    ? this.connectViaThread()\n    : this.connectViaManager();\n\n  return this.connected.then(function(service) {\n    debug('connected', service);\n    self.service.id = service.id;\n    thread.connection('outbound');\n  });\n};\n\n/**\n * Attempt to connect directly with a\n * `Service` that lives inside a thread.\n *\n * @return {Promise}\n */\n\nClient.prototype.connectViaThread = function() {\n  debug('connecting via thread...');\n  var self = this;\n  return this.thread.getService(self.service.name)\n    .then(function(service) {\n      debug('got service', service);\n      self.thread.on('message', self.messenger.parse);\n      return self.messenger.request(self.thread, {\n        type: 'connect',\n        recipient: service.id,\n        data: {\n          client: self.id,\n          service: service.name,\n          contract: self.contract\n        }\n      });\n    })\n    .then(function(service) {\n      self.thread.off('message', self.messenger.parse);\n      return service;\n    });\n};\n\n/**\n * Broadcasts a 'connect' message on the\n * 'manager' channel to indicate that a\n * client wants to connect with a\n * particular service.\n *\n * This message will either be handled\n * by a manager that handles this service\n * name, or a prexisting service of this name.\n *\n * NOTE: Potentially if the is more than\n * one service of the same name running\n * the client could end up connecting\n * to the wrong service.\n *\n * Right now this produces quite a lot of noise\n * as every Service and every Manager will\n * respond to to messages on the 'threadsmanager'\n * channel.\n *\n * @private\n */\n\nClient.prototype.connectViaManager = function() {\n  debug('connecting via manager...');\n  var onmessage = this.messenger.parse;\n  manager.addEventListener('message', onmessage);\n  return this.messenger.request(manager, {\n    type: 'connect',\n    recipient: '*',\n    data: {\n      service: this.service.name,\n      client: this.id\n    }\n  }).then(function(result) {\n    manager.removeEventListener('message', onmessage);\n    return result;\n  });\n};\n\n/**\n * Disconnect with the `Service`.\n *\n * You must call this if the `Manager`\n * is to destroy threads. If a thread\n * has `Services` that have connected\n * `Client`s then it is 'in-use'.\n *\n * Once we recieve the responce, the service\n * is pinged one last time to let it know\n * that the client-side has disconnected.\n *\n * @return {Promise}\n */\n\nClient.prototype.disconnect = function() {\n  debug('disconnect');\n  if (!this.connected) return Promise.resolve();\n  return this.request('disconnect', this.id)\n    .then(function() {\n      this.service.channel.close();\n      delete this.service.channel;\n      delete this.service.id;\n      delete this.connected;\n      thread.disconnection('outbound');\n      debug('disconnected');\n    }.bind(this));\n};\n\n/**\n * Make an outbound request to the `Service`.\n *\n * When the `Client` is not yet connected,\n * the request is added to a queue that\n * is flushed once a connection is made.\n *\n * @param  {String} type\n * @param  {Object} data\n * @return {Promise}\n */\n\nClient.prototype.request = function(type, data) {\n  debug('request', type, data);\n  return this.connect().then(function() {\n    return this.messenger.request(this.service.channel, {\n      type: type,\n      recipient: this.service.id,\n      data: data\n    });\n  }.bind(this));\n};\n\n/**\n * Triggered when a `Service` broadcasts\n * an event to all connected `Client`s.\n *\n * The event is emitted on the `Client`s\n * internal `Emitter` so users can\n * listen via `client.on('foo', ...)`\n *\n * @param  {Object} broadcast\n */\n\nClient.prototype.onbroadcast = function(broadcast) {\n  debug('on broadcast', broadcast);\n  this.emit(broadcast.type, broadcast.data);\n};\n\n/**\n * Call a method on the service.\n *\n * Promise will be resolved when service\n * responds with the data or rejected\n * when service throws an error or\n * returns a rejected promise.\n *\n * @param {String} method Name of the method to be called\n * @param {*} [...rest] data to be passed to to the method\n * @returns {Promise}\n * @public\n */\n\nClient.prototype.method = function(method) {\n  var args = [].slice.call(arguments, 1);\n  debug('method', method, args);\n  return this.request('method', {\n    name: method,\n    args: args\n  });\n};\n\n/**\n * Call an action on the service.\n *\n * Used mainly for cases where service\n * needs to send data in chunks and/or\n * when you need to `cancel` the\n * action before it's complete.\n *\n * @param {String} method Name of the method to be called\n * @param {*} [...rest] data to be passed to to the method\n * @returns {ClientStream}\n * @public\n */\n\nClient.prototype.stream = function(method) {\n  debug('stream', method, args);\n  var args = [].slice.call(arguments, 1);\n  var self = this;\n\n  // Use an unique id to identify the\n  // stream. We pass this value to the\n  // service as well so we can map the\n  // service and client streams.\n  // They are different instances\n  // that are 'connected' through\n  // the bridge by this id.\n  var id = utils.uuid();\n  var stream = new ClientStream({\n    id: id,\n    client: this\n  });\n\n  this._activeStreams[id] = stream;\n  this.request('stream', {\n    name: method,\n    args: args,\n    id: id\n  }).catch(function(err) {\n    self.onstreamevent({\n      type: 'abort',\n      id: id,\n      data: err\n    });\n  });\n\n  return stream;\n};\n\n/**\n * Called every time the service calls\n * write/abort/close on the ServiceStream\n *\n * @param {Object} broadcast\n * @param {String} broadcast.id Stream ID\n * @param {String} broadcast.type Event type ('write', 'abort' or 'close')\n * @private\n */\n\nClient.prototype.onstreamevent = function(broadcast) {\n  var id = broadcast.id;\n  var type = broadcast.type;\n  var stream = this._activeStreams[id];\n\n  stream._[type](broadcast.data);\n  if (type === 'abort' || type === 'close') {\n    delete this._activeStreams[id];\n  }\n};\n","'use strict';\n\n/**\n * Dependencies\n */\n\nvar Emitter = require('../emitter');\nvar utils = require('../utils');\n\n/**\n * Exports\n */\n\nmodule.exports = ClientStream;\n\n/**\n * Mini Logger\n *\n * @type {Function}\n */\n\nvar debug = 1 ? console.log.bind(console, '[ClientStream]') : function() {};\n\n/**\n * Readable stream instance returned by\n * a `client.stream('methodName')` call.\n *\n * @param {Object} options\n * @param {String} options.id Stream Id, used to match client/service streams\n * @param {Client} options.client Client instance\n */\n\nfunction ClientStream(options) {\n  this._ = new ClientStreamPrivate(options);\n}\n\n/**\n * Promise that will be \"resolved\" when\n * stream is closed with success, and\n * \"rejected\" when service aborts\n * the action (abort == error).\n *\n * @type Promise\n */\n\nObject.defineProperty(ClientStream.prototype, 'closed', {\n  get: function() { return this._.closed.promise; }\n});\n\n/**\n * Add a listener that will be called\n * every time the service broadcasts\n * a new chunk of data.\n *\n * @param {Function} callback\n */\n\nClientStream.prototype.listen = function(callback) {\n  debug('listen', callback);\n  this._.emitter.on('write', callback);\n};\n\n/**\n * Removes 'data' listener\n *\n * @param {Function} callback\n */\n\nClientStream.prototype.unlisten = function(callback) {\n  debug('unlisten', callback);\n  this._.emitter.off('write', callback);\n};\n\n/**\n * Notify the service that\n * action should be canceled\n *\n * @param {*} [reason] Optional data to be sent to service.\n */\n\nClientStream.prototype.cancel = function(reason) {\n  debug('cancel', reason);\n\n  var canceled = utils.deferred();\n  var client = this._.client;\n  var id = this._.id;\n\n  client.request('streamcancel', {\n    id: id,\n    reason: reason\n  }).then(function(data) {\n    delete client._activeStreams[id];\n    canceled.resolve(data);\n  }).catch(function(e) {\n    // should delete the `_activeStreams`\n    // reference even if it didn't succeed\n    delete client._activeStreams[id];\n    canceled.reject(e);\n  });\n\n  return canceled.promise;\n};\n\n/**\n * Initialize a new `ClientStreamPrivate`.\n *\n * @param {Object} options\n * @private\n */\n\nfunction ClientStreamPrivate(options) {\n  this.id = options.id;\n  this.client = options.client;\n  this.closed = utils.deferred();\n  this.emitter = new Emitter();\n  debug('initialized');\n}\n\n/**\n * Used internally by Client when\n * it receives an 'abort' event\n * from the service.\n *\n * @private\n */\n\nClientStreamPrivate.prototype.abort = function(reason) {\n  debug('abort', reason);\n  this.closed.reject(reason);\n};\n\n/**\n * Used internally by Client when\n * it receives a 'close' event\n * from the service.\n *\n * @private\n */\n\nClientStreamPrivate.prototype.close = function() {\n  debug('close');\n  this.closed.resolve();\n};\n\n/**\n * Used internally by Client when\n * it receives a 'write' event\n * from the service.\n *\n * @private\n */\n\nClientStreamPrivate.prototype.write = function(data) {\n  debug('write', data);\n  this.emitter.emit('write', data);\n};\n","'use strict';\n\n/**\n * Exports\n */\n\nmodule.exports = Emitter;\n\n/**\n * Simple logger\n *\n * @type {Function}\n */\n\nvar debug = 1 ? console.log.bind(console, '[Emitter]') : function(){};\n\n/**\n * Create new `Emitter`\n *\n * @constructor\n */\nfunction Emitter() {}\n\n/**\n * Add an event listener.\n *\n * It is possible to subscript to * events.\n *\n * @param  {String}   type\n * @param  {Function} callback\n * @return {Emitter} for chaining\n */\nEmitter.prototype.on = function(type, callback) {\n  debug('on', type, callback);\n  if (!this._callbacks) this._callbacks = {};\n  if (!this._callbacks[type]) this._callbacks[type] = [];\n  this._callbacks[type].push(callback);\n  return this;\n};\n\n/**\n * Remove an event listener.\n *\n * Example:\n *\n *   emitter.off('name', fn); // remove one callback\n *   emitter.off('name'); // remove all callbacks for 'name'\n *   emitter.off(); // remove all callbacks\n *\n * @param  {String} type (optional)\n * @param  {Function} callback (optional)\n * @return {Emitter} for chaining\n */\nEmitter.prototype.off = function(type, callback) {\n  debug('off', type, callback);\n  if (this._callbacks) {\n    switch (arguments.length) {\n      case 0: this._callbacks = {}; break;\n      case 1: delete this._callbacks[type]; break;\n      default:\n        var typeListeners = this._callbacks[type];\n        if (!typeListeners) return;\n        var i = typeListeners.indexOf(callback);\n        if (~i) typeListeners.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit an event.\n *\n * Example:\n *\n *   emitter.emit('name', { some: 'data' });\n *\n * @param  {String} type\n * @param  {*} data\n * @return {Emitter} for chaining\n */\nEmitter.prototype.emit = function(type, data) {\n  debug('emit', type, data);\n  if (this._callbacks) {\n    var fns = this._callbacks[type] || [];\n    fns = fns.concat(this._callbacks['*'] || []);\n    for (var i = 0; i < fns.length; i++) fns[i].call(this, data, type);\n  }\n  return this;\n};\n","'use strict';\n\n/**\n * Dependencies\n */\n\nvar ChildThread = require('./child-thread');\nvar Messenger = require('./messenger');\n\n/**\n * Exports\n */\n\nmodule.exports = Manager;\n\n/**\n * Simple logger\n *\n * @type {Function}\n */\nvar debug = 1 ? console.log.bind(console, '[Manager]') : function() {};\n\n/**\n * Global 'manager' channel\n *\n * @type {BroadcastChannel}\n */\nvar channel = new BroadcastChannel('threadsmanager');\n\n/**\n * Initialize a new `Manager`\n *\n * @param {Object} descriptors Service descriptors\n */\nfunction Manager(descriptors) {\n  if (!(this instanceof Manager)) return new Manager(descriptors);\n  this._ = new ManagerPrivate(descriptors);\n}\n\n/**\n * Destroy the manager and any\n * threads it's spawned.\n *\n * @public\n */\nManager.prototype.destroy = function() {\n  this._.destroy();\n};\n\n/**\n * Hidden `Manager` methods and state.\n *\n * @param {Object} descriptors\n */\nfunction ManagerPrivate(descriptors) {\n  this.id = 'threadsmanager';\n  this.registry = {};\n  this.threads = {};\n\n  this.messenger = new Messenger(this.id, '[Manager]')\n    .handle('connect', this.onconnect, this);\n\n  channel.addEventListener('message', this.messenger.parse);\n  this.register(descriptors);\n  debug('intialized');\n}\n\n/**\n * Destroy the `Manager`.\n *\n * @private\n */\nManagerPrivate.prototype.destroy = function() {\n  debug('destroy');\n  if (this.destroyed) return;\n  channel.removeEventListener('message', this.messenger.parse);\n  this.destroyThreads();\n  delete this.registry;\n  delete this.threads;\n  this.destroyed = true;\n};\n\n/**\n * Destroy all threads this Manager created.\n *\n * @private\n */\nManagerPrivate.prototype.destroyThreads = function() {\n  debug('destroy threads');\n  for (var src in this.threads) this.destroyThread(this.threads[src]);\n};\n\n/**\n * Register service descriptors.\n *\n * @param  {Object} descriptors\n * @private\n */\nManagerPrivate.prototype.register = function(descriptors) {\n  debug('register', descriptors);\n  for (var name in descriptors) {\n    descriptors[name].name = name;\n    this.registry[name] = descriptors[name];\n  }\n};\n\n/**\n * Run when a client attempts to connect.\n *\n * If a contract is found in the service\n * descriptor we pass it to the service\n * along with the connect request.\n *\n * @param  {Object} data {service,client,contract}\n * @private\n */\nManagerPrivate.prototype.onconnect = function(request) {\n  debug('on connect');\n  var data = request.data;\n  var descriptor = this.registry[data.service];\n\n  if (!descriptor) return debug('\"%s\" not managed here', data.service);\n\n  var self = this;\n  var client = data.client;\n  var contract = descriptor.contract;\n  var thread = this.getThread(descriptor);\n\n  request.respond(\n    thread.getService(descriptor.name)\n      .then(function(service) {\n        return self.connect(client, service, contract);\n      })\n  );\n};\n\n/**\n * Connect a Client to a Service.\n *\n * @param  {String} client   Client ID\n * @param  {Object} service  {id,name}\n * @param  {Object} contract (optional)\n * @return {Promise}\n */\nManagerPrivate.prototype.connect = function(client, service, contract) {\n  debug('connect', service, client, contract);\n  return this.messenger.request(channel, {\n    type: 'connect',\n    recipient: service.id,\n    data: {\n      client: client,\n      service: service.name,\n      contract: contract\n    }\n  });\n};\n\n/**\n * Get a thread for a given service\n * descriptor. If there is no existing\n * thread we create one.\n *\n * @param  {Object} descriptor  Service descriptor\n * @return {ChildThread}\n */\nManagerPrivate.prototype.getThread = function(descriptor) {\n  debug('get thread', descriptor);\n  var thread = this.threads[descriptor.src];\n  return thread || this.createThread(descriptor);\n};\n\n/**\n * Create a new `ChildThread` for\n * the given `Service` descriptor.\n *\n * @param  {Object} descriptor\n * @return {ChildThread}\n */\nManagerPrivate.prototype.createThread = function(descriptor) {\n  debug('create thread', descriptor);\n  var thread = new ChildThread(descriptor);\n  var self = this;\n\n  this.threads[thread.src] = thread;\n  thread.on('redundant', function fn() {\n    thread.off('redundant', fn);\n    self.destroyThread(thread);\n  });\n\n  return thread;\n};\n\n/**\n * Destroy a thread.\n *\n * @param  {ChildThread} thread\n */\nManagerPrivate.prototype.destroyThread = function(thread) {\n  debug('destroy thread');\n  thread.destroy();\n  delete this.threads[thread.src];\n};\n","'use strict';\n\n/**\n * Dependencies\n */\n\nvar utils = require('./utils');\n\n/**\n * Mini Logger\n *\n * @type {Function}\n */\n\nvar debug = 1 ? console.log.bind(console, '[Messenger]') : function() {};\n\n/**\n * Exports\n */\n\nmodule.exports = Messenger;\n\n/**\n * Instantiate a new `Messenger`.\n *\n * A Messenger is a common interface to\n * send and receive messages over a channel\n * that connects threads.\n *\n * It has no concept of `Client` or `Service`\n * it simply acts as a sender and reciever\n * of messages.\n *\n * @param {Number} id\n * @name {String} name (optional) passed to debug() logs\n */\n\nfunction Messenger(id, name) {\n  this.id = id;\n  this.name = name;\n  this.handlers = {};\n  this.pending = {};\n  this.history = new Array(10);\n  this.parse = this.parse.bind(this);\n  debug('initialized', this.name);\n}\n\n/**\n * Register a handler for a message type.\n *\n * NOTE: Only one handler per message type allowed.\n *\n * @param  {String}   type\n * @param  {Function} fn\n * @param  {Object}   ctx\n * @return {Messenger} for chaining\n */\n\nMessenger.prototype.handle = function(type, fn, ctx) {\n  this.handlers[type] = { fn: fn, ctx: ctx };\n  return this;\n};\n\n/**\n * Unregister a handler for a message type.\n *\n * As we only accept one handler per message\n * type, a callback function is not required.\n *\n * @param  {String} type\n * @return {Messenger} for chaining\n */\n\nMessenger.prototype.unhandle = function(type) {\n  delete this.handlers[type];\n  return this;\n};\n\n/**\n * Parses raw message event objects\n * an triggers handlers if validity\n * checks are passed.\n *\n * Users of `Message` should wire this\n * up to their Channel's `.onmessage`\n * callback.\n *\n * @param  {Event} e\n * @public\n */\n\nMessenger.prototype.parse = function(e) {\n  var message = e.data;\n\n  if (!this.isRecipient(message)) return;\n  if (this.hasRead(message)) return;\n\n  debug('parse', this.name, e);\n  var handler = this['on' + message.type];\n\n  if (handler) {\n    handler.call(this, e);\n    this.read(message);\n  }\n};\n\n/**\n * Request is used to send a message to\n * a channel and expects a response.\n *\n * The returned `Promise` will fulfill\n * with the value passed to `request.respond()`\n * by the first responding handler.\n *\n * @param  {Object} channel [BroadcastChannel, Window, ChildThread]\n * @param  {Object} params  {recipient, type, data}\n * @return {Promise}\n */\n\nMessenger.prototype.request = function(channel, params) {\n  debug('request', this.name, params);\n  var deferred = utils.deferred();\n  var id = utils.uuid();\n\n  send(channel, {\n    type: 'request',\n    sender: this.id,\n    recipient: params.recipient,\n    data: {\n      id: id,\n      type: params.type,\n      data: params.data\n    }\n  });\n\n  this.pending[id] = deferred;\n  return deferred.promise;\n};\n\n/**\n * Push is used to send a one-way message\n * to a channel and doesn't provide a\n * way to respond.\n *\n * @param  {Object} channel [BroadcastChannel,Window,ChildThread]\n * @param  {Object} params  {recipient,type,data}\n */\n\nMessenger.prototype.push = function(channel, params) {\n  debug('push', channel, params);\n  send(channel, {\n    type: 'push',\n    sender: this.id,\n    recipient: params.recipient,\n    data: {\n      type: params.type,\n      data: params.data\n    }\n  });\n};\n\n/**\n * Handles incoming 'request' messages.\n *\n * It attempts to find a matching handler,\n * if found it calls it passing a `Request`\n * object that the handler can use to respond.\n *\n * In the event that a handler throws an\n * exception, this will be caught and\n * we .respond() on the handler's behalf.\n *\n * @param  {Event} e Raw message event.\n * @private\n */\n\nMessenger.prototype.onrequest = function(e) {\n  debug('on request', e);\n  var request = new Request(e);\n  var handler = this.handlers[request.type];\n\n  if (!handler) return;\n\n  try { handler.fn.call(handler.ctx, request); }\n  catch (e) {\n    request.respond(e);\n    console.error(e); // Should this throw?\n  }\n};\n\n/**\n * Handles incoming 'response' messages.\n *\n * Attempts to find a pending request\n * that matches the `requestId` of\n * the response. If found it resolves\n * or rejects the `Promise` based on\n * the response result.\n *\n * @param  {Event} e Raw message event\n * @private\n */\n\nMessenger.prototype.onresponse = function(e) {\n  debug('on response', this.name, response);\n  var message = e.data;\n  var response = message.data;\n  var requestId = response.request;\n  var promise = this.pending[requestId];\n\n  if (!promise) return debug('no promise', this.pending);\n\n  var result = response.result;\n  var method = {\n    'fulfilled': 'resolve',\n    'rejected': 'reject'\n  }[result.state];\n\n  // The value resided under a different\n  // key depending on whether the promise\n  // was 'rejected' or 'resolved'\n  var value = result.value || result.reason;\n  promise[method](value);\n\n  // Clean up\n  delete this.pending[requestId];\n};\n\n/**\n * Handles incoming 'push' messages.\n *\n * Attempts to find a handler that matches\n * the push 'type' and calls it with the\n * data passed.\n *\n * The logic is a lot simpler than onrequest\n * and onresponse as `.push()` doesn't\n * expect a reply.\n *\n * We could kill `.push()` and use `.request()`\n * for everything, but that means that either\n * we'd have to send responses for all\n * messages (even when not required) or\n * we'd have to expire requests in\n * `this.pending`.\n *\n * Overall `.push()` is a more efficient\n * way to send messages.\n *\n * @param  {Event} e Raw message event\n */\n\nMessenger.prototype.onpush = function(e) {\n  var message = e.data;\n  var push = message.data;\n  debug('on push', push);\n  var handler = this.handlers[push.type];\n  if (handler) handler.fn.call(handler.ctx, push.data);\n};\n\n/**\n * Check if this messenger is an\n * intended recipient.\n *\n * @param  {Object}  message\n * @return {Boolean}\n */\n\nMessenger.prototype.isRecipient = function(message) {\n  var recipient = message.recipient;\n  return recipient === this.id || recipient === '*';\n};\n\n/**\n * Keeping track of read messages means\n * that we'll never accidentally read\n * the same message twice.\n *\n * @param  {Object} message\n */\n\nMessenger.prototype.read = function(message) {\n  this.history.push(message.id);\n  this.history.shift();\n};\n\n/**\n * Check if the message has already been read.\n *\n * @param  {Object}  message\n * @return {Boolean}\n */\n\nMessenger.prototype.hasRead = function(message) {\n  return !!~this.history.indexOf(message.id);\n};\n\n/**\n * Create a new `Request`.\n *\n * A request is an object that represents an\n * incoming request message. It provides\n * the receiver with an opportunity to\n * `.respond('result')`.\n *\n * Any message handlers that match an\n * incoming request `type` will be passed\n * one of these `Request` objects.\n *\n * @param {MessageEvent} e Raw message Event to parse\n */\n\nfunction Request(e) {\n  var message = e.data;\n  var request = message.data;\n\n  this.id = request.id;\n  this.channel = e.source || e.target;\n  this.sender = message.sender;\n  this.type = request.type;\n  this.data = request.data;\n  this.responded = false;\n}\n\n\n/**\n * Respond to a request.\n *\n * The result passed to this function\n * will be sent back to the sender.\n *\n * If an `Error` is passed back the\n * pending `Promise` will be rejected\n * on the sender's end.\n *\n * @param  {*} result\n */\n\nRequest.prototype.respond = function(result) {\n  debug('respond');\n  if (this.responded) return;\n  this.responded = true;\n\n  var self = this;\n\n  // Repsond with rejection when result is an `Error`\n  if (result instanceof Error) reject(result);\n\n  // Call the handler and make\n  // sure return value is a promise\n  return Promise.resolve(result).then(resolve, reject);\n\n  function resolve(value) {\n    debug('resolved', value);\n    respond({\n      state: 'fulfilled',\n      value: value\n    });\n  }\n\n  function reject(err) {\n    debug('rejected', err.message);\n    respond({\n      state: 'rejected',\n      reason: err.message || err\n    });\n  }\n\n  function respond(result) {\n    send(self.channel, {\n      type: 'response',\n      recipient: self.sender,\n      data: {\n        request: self.id,\n        result: result\n      }\n    });\n  }\n};\n\n/**\n * Send a message via a particular channel.\n *\n * A 'channel' is an object with a `.postMessage`\n * method. In our case `iframe.contentWindow`,\n * `BroadCastChannel` or `ChildThread`.\n *\n * @param  {Object} channel\n * @param  {Object} params\n * @private\n */\n\nfunction send(channel, params) {\n  debug('send', channel, params);\n  var isWindow = channel.constructor.name === 'Window';\n  var message = {\n    type: params.type,\n    id: utils.uuid(),\n    recipient: params.recipient || '*',\n    sender: params.sender,\n    data: params.data\n  };\n\n  // Window and BroadcastChannel take different arguments\n  if (isWindow) channel.postMessage(message, '*');\n  else channel.postMessage(message);\n}\n","'use strict';\n\n/**\n * Dependencies\n */\n\nvar thread = require('../thread-global');\nvar Messenger = require('../messenger');\nvar ServiceStream = require('./stream');\nvar utils = require('../utils');\n\n/**\n * exports\n */\n\nexports = module.exports = Service;\nexports.Stream = ServiceStream; // for testing\n\n/**\n * Mini Logger\n *\n * @type {Function}\n */\n\nvar debug = 1 ? console.log.bind(console, '[Service]') : function(){};\n\n/**\n * Global broadcast channel that\n * the Manager can use to pair\n * a Client with a Service.\n *\n * @type {BroadcastChannel}\n */\n\nvar manager = new BroadcastChannel('threadsmanager');\n\n/**\n * Initialize a new `Service`\n *\n * @param {String} name\n */\n\nfunction Service(name) {\n  if (!(this instanceof Service)) return new Service(name);\n  this.name = name;\n  this.private = new ServicePrivate(this);\n  debug('initialized', this.name);\n}\n\n/**\n * Register a method that will be\n * exposed to all the clients.\n *\n * @param {String} name Method name\n * @param {Function} fn Implementation\n */\n\nService.prototype.method = function(name, fn) {\n  this.private.addMethod(name, fn);\n  return this;\n};\n\n/**\n * Register a method that sends data through a writable stream.\n *\n * @param {String} name Method name\n * @param {Function} fn Implementation\n */\n\nService.prototype.stream = function(name, fn) {\n  this.private.addStream(name, fn);\n  return this;\n};\n\n/**\n * Register a contract that will be used\n * to validate method calls and events.\n *\n * @param {Object} contract\n */\n\nService.prototype.contract = function(contract) {\n  this.private.setContract(contract);\n  return this;\n};\n\n/**\n * Broadcast message to all the clients.\n *\n * @param {String} type Event name.\n * @param {*} data Payload to be transmitted.\n */\n\nService.prototype.broadcast = function(type, data, clients) {\n  this.private.broadcast(type, data, clients);\n  return this;\n};\n\n/**\n * All the logic is contained inside\n * this 'private' class. Public methods\n * on `Service` proxy to `ServicePrivate`.\n *\n * @param {Service} service\n * @param {String} name\n */\n\nfunction ServicePrivate(service) {\n  debug('initialize', service);\n\n  this.public = service;\n  this.name = service.name;\n  this.id = utils.uuid();\n  this.contract = null;\n  this.methods = {};\n  this.channels = {};\n  this.streams = {};\n  this.activeStreams = {};\n\n  this.messenger = new Messenger(this.id, '[Service]')\n    .handle('connect', this.onconnect, this)\n    .handle('stream', this.onstream, this)\n    .handle('streamcancel', this.onstreamcancel, this)\n    .handle('method', this.onmethod, this)\n    .handle('disconnect', this.ondisconnect, this);\n\n  this.listen();\n\n  // Don't declare service ready until\n  // any pending tasks in the event-loop\n  // have completed. Namely any pending\n  // 'connect' events for `SharedWorkers`.\n  // If we broadcast the 'serviceready'\n  // event before the thread-parent has\n  // 'connected', it won't be heard.\n  setTimeout(this.ready.bind(this));\n}\n\n/**\n * Called when a client calls\n * a service's method.\n *\n * @param  {Object} method\n * @return {*}\n */\n\nServicePrivate.prototype.onmethod = function(request) {\n  debug('method', request.data);\n  var method = request.data;\n  var fn = this.methods[method.name];\n  if (!fn) throw error(4, method.name);\n  this.checkMethodCall(method);\n  var result = fn.apply(this.public, method.args);\n  request.respond(result);\n};\n\n/**\n * Called during `client.stream()`\n *\n * @param {Object} method\n * @param {String} method.name Name of the function to be executed\n * @param {String} method.id Stream Id, used to sync client and service streams\n * @param {Object} request Request object\n */\n\nServicePrivate.prototype.onstream = function(request) {\n  debug('stream', request.data);\n  var data = request.data;\n  var fn = this.streams[data.name];\n  var client = request.sender;\n\n  if (!fn) throw error(6, data.name);\n\n  var id = data.id;\n  var stream = new ServiceStream({\n    id: id,\n    channel: this.channels[client],\n    serviceId: this.id,\n    clientId: client\n  });\n\n  this.activeStreams[id] = stream;\n\n  // always pass stream object as first\n  // argument to simplify the process\n  fn.apply(this.public, [stream].concat(data.args));\n\n  // stream doesn't return anything on purpose,\n  // we create another stream object\n  // on the client during request\n  request.respond();\n};\n\n/**\n * Called when client requests for `streamcancel`\n *\n * @param {*} data Data sent from client (reason for cancelation).\n * @return {Promise}\n * @private\n */\n\nServicePrivate.prototype.onstreamcancel = function(request) {\n  var data = request.data;\n  var id = data.id;\n  var stream = this.activeStreams[id];\n  delete this.activeStreams[id];\n  request.respond(stream._.cancel(data.reason));\n};\n\n/**\n * Once the service is 'ready', we\n * postMessage out of the global\n * thread scope so that the parent\n * of the thread ('manager' or manual)\n * knows that they can proceed with\n * the connection request.\n *\n * @private\n */\n\nServicePrivate.prototype.ready = function() {\n  debug('ready');\n  thread.serviceReady(this);\n};\n\n/**\n * Runs on an inbound connection\n * attempt from a client.\n *\n * A new dedicated `BroadcastChannel`\n * is opened for each client.\n *\n * A 'connected' message is sent down the\n * new client channel to confirm the\n * connection.\n *\n * @param  {Object} data\n */\n\nServicePrivate.prototype.onconnect = function(request) {\n  var data = request.data;\n  var client = data.client;\n  var contract = data.contract;\n  var service = data.service;\n\n  if (!client) return;\n  if (service !== this.name) return;\n  if (this.channels[client]) return;\n\n  debug('on connect', this.id, data);\n  var channel = new BroadcastChannel(client);\n  channel.onmessage = this.messenger.parse;\n  this.channels[client] = channel;\n\n  this.setContract(contract);\n  thread.connection('inbound');\n  debug('connected', client);\n\n  request.respond({\n    id: this.id,\n    name: this.name\n  });\n};\n\n/**\n * Responds to `Client` request to disconnect.\n *\n * All the cleanup is done after we have\n * sent the response as we need the\n * channel to send the message back.\n *\n * @param  {Request} request\n */\n\nServicePrivate.prototype.ondisconnect = function(request) {\n  var client = request.data;\n\n  // Check `Client` is known\n  if (!this.channels[client]) return;\n  debug('on disconnect', client);\n\n  var deferred = utils.deferred();\n\n  // TODO: Check there are no requests/methods\n  // pending for this client, before disconnecting.\n\n  deferred.resolve();\n\n  deferred.promise.then(function() {\n    return request.respond();\n  }).then(function() {\n    debug('disconnected', client);\n    this.channels[client].close();\n    delete this.channels[client];\n    thread.disconnection('inbound');\n  }.bind(this));\n};\n\nServicePrivate.prototype.setContract = function(contract) {\n  if (!contract) return;\n  this.contract = contract;\n  debug('contract set', contract);\n};\n\n/**\n * Add a method to the method registry.\n *\n * TODO: We should check the the\n * `name` and function signature\n * match anything defined in the\n * contract. Or perhaps this could\n * be done in `.setContract()`?\n *\n * @param {String}   name\n * @param {Function} fn\n */\n\nServicePrivate.prototype.addMethod = function(name, fn) {\n  this.methods[name] = fn;\n};\n\n\n/**\n * Add a method to the stream registry.\n *\n * @param {String}   name\n * @param {Function} fn\n */\n\nServicePrivate.prototype.addStream = function(name, fn) {\n  this.streams[name] = fn;\n};\n\n/**\n * Check a method call matches a registered\n * method and that the arguments passed\n * adhere to a defined contract.\n *\n * Throws an error when invalid.\n *\n * @param  {Object} method\n */\n\nServicePrivate.prototype.checkMethodCall = function(method) {\n  debug('check method call', method);\n\n  var name = method.name;\n  var args = method.args;\n\n  if (!this.contract) return;\n\n  var signature = this.contract.methods[name];\n  var e;\n\n  if (!signature) e = error(1, name);\n  else if (args.length !== signature.length) e = error(2, name, signature.length);\n  else if (!utils.typesMatch(args, signature)) e = error(5);\n\n  if (e) throw e;\n};\n\n/**\n * Listens for incoming messsages from\n * the `thread` global and `manager` channel.\n *\n * `this.onmessage` filters out messages\n * that aren't intended for this instance.\n *\n * @private\n */\n\nServicePrivate.prototype.listen = function() {\n  manager.addEventListener('message', this.messenger.parse);\n  thread.on('message', this.messenger.parse);\n};\n\n/**\n * Broadcast a message to all\n * connected clients.\n *\n * @param  {String} type\n * @param  {*} data to pass with the event\n * @param  {Array} (optional) array of client-ids to target\n */\n\nServicePrivate.prototype.broadcast = function(type, data, clients) {\n  debug('broadcast', type, data);\n  for (var client in this.channels) {\n    if (clients && !~clients.indexOf(client)) continue;\n    this.messenger.push(this.channels[client], {\n      type: 'broadcast',\n      recipient: client,\n      data: {\n        type: type,\n        data: data\n      }\n    });\n  }\n};\n\n/**\n * Utils\n */\n\nfunction error(id) {\n  /*jshint maxlen:false*/\n  var args = [].slice.call(arguments, 1);\n  return new Error({\n    1: 'method \"' + args[0] + '\" not defined in the contract',\n    2: 'expected method \" ' + args[0] + '\" to be called with ' + args[1]+ ' arguments',\n    3: 'unknown request type: \"' + args[0] + '\"',\n    4: 'method \"' + args[0] + '\" doesn\\'t exist',\n    5: 'arguments types don\\'t match contract',\n    6: 'stream \"' + args[0] + '\" doesn\\'t exist',\n  }[id]);\n}\n","'use strict';\n\n/**\n * Dependencies\n */\n\nvar Messenger = require('../messenger');\n\n/**\n * Exports\n */\n\nmodule.exports = ServiceStream;\n\n/**\n * Mini Logger\n *\n * @type {Function}\n */\n\nvar debug = 1 ? console.log.bind(console, '[ServiceStream]') : function() {};\n\n/**\n * Writable Stream instance passed to the\n * `service.stream` implementation\n *\n * @param {Object} options\n * @param {String} options.id Stream ID used to sync client and service streams\n * @param {BroadcastChannel} options.channel Channel used to postMessage\n * @param {String} options.serviceId ID of the service\n * @param {String} options.clientId ID of client that should receive message\n */\n\nfunction ServiceStream(options) {\n  this._ = new PrivateServiceStream(this, options);\n}\n\n/**\n * Services that allows clients to\n * cancel the operation before it's\n * complete should override the\n * `stream.cancel` method.\n *\n * @param {*} [reason] Data sent from client about the cancellation\n * @returns {(Promise|*)}\n */\n\nServiceStream.prototype.cancel = function(reason) {\n  var err = new TypeError('service should implement stream.cancel()');\n  return Promise.reject(err);\n};\n\n/**\n * Signal to client that action was\n * aborted during the process, this\n * should be used as a way to\n * communicate errors.\n *\n * @param {*} [data] Reason of failure\n * @returns {Promise}\n */\n\nServiceStream.prototype.abort = function(data) {\n  debug('abort', data);\n  return this._.post('abort', 'aborted', data);\n};\n\n/**\n * Sends a chunk of data to the client.\n *\n * @param {*} data Chunk of data to be sent to client.\n * @returns {Promise}\n */\n\nServiceStream.prototype.write = function(data) {\n  debug('write', data);\n  return this._.post('write', 'writable', data);\n};\n\n/**\n * Closes the stream, signals that\n * action was completed with success.\n *\n * According to whatwg streams spec,\n * WritableStream#close() doesn't send data.\n *\n * @returns {Promise}\n */\n\nServiceStream.prototype.close = function() {\n  debug('close');\n  return this._.post('close', 'closed');\n};\n\n/**\n * Initialize a new `ClientStreamPrivate`.\n *\n * @param {ServiceStream} target\n * @param {Object} options\n * @private\n */\n\nfunction PrivateServiceStream(target, options) {\n  this.target = target;\n  this.id = options.id;\n  this.channel = options.channel;\n  this.client = options.clientId;\n  this.state = 'writable';\n  this.messenger = new Messenger(options.serviceId, '[ServiceStream]');\n  debug('initialized', target, options);\n}\n\n/**\n * Validate the internal state to avoid\n * passing data to the client when stream\n * is already 'closed/aborted/canceled'.\n *\n * Returns a Stream to simplify the 'cancel'\n * & 'post' logic since they always need\n * to return promises.\n *\n * @param {String} actionName\n * @param {String} state\n * @returns {Promise}\n * @private\n */\n\nPrivateServiceStream.prototype.validateState = function(actionName, state) {\n  if (this.state !== 'writable') {\n    var msg = 'Can\\'t ' + actionName + ' on current state: ' + this.state;\n    return Promise.reject(new TypeError(msg));\n  }\n\n  this.state = state;\n  return Promise.resolve();\n};\n\n/**\n * Validate the current state and\n * call cancel on the target stream.\n *\n * Called by the Service when client\n * sends a 'streamcancel' message.\n *\n * @param {*} [reason] Reason for cancelation sent by the client\n * @returns {Promise}\n * @private\n */\n\nPrivateServiceStream.prototype.cancel = function(reason) {\n  return this.validateState('cancel', 'canceled').then(function() {\n    return this.target.cancel(reason);\n  }.bind(this));\n};\n\n/**\n * Validate the current state and post message to client.\n *\n * @param {String} type 'write', 'abort' or 'close'\n * @param {String} state 'writable', 'aborted' or 'closed'\n * @param {*} [data] Data to be sent to the client\n * @returns {Promise}\n * @private\n */\n\nPrivateServiceStream.prototype.post = function(type, state, data) {\n  debug('post', type, state, data);\n  return this.validateState(type, state).then(function() {\n    debug('validated', this.channel);\n    this.messenger.push(this.channel, {\n      type: 'streamevent',\n      recipient: this.client,\n      data: {\n        id: this.id,\n        type: type,\n        data: data\n      }\n    });\n  }.bind(this));\n};\n","'use strict';\n\n/**\n * Dependencies\n */\n\nvar Messenger = require('./messenger');\nvar emitter = require('./emitter');\nvar utils = require('./utils');\n\n/**\n * Mini Logger\n *\n * @type {Function}\n */\n\nvar debug = 1 ? console.log.bind(console, '[ThreadGlobal]') : function() {};\n\n/**\n * Extend `Emitter`\n */\n\nThreadGlobal.prototype = Object.create(emitter.prototype);\n\n/**\n * Initialize a new `ThreadGlobal`.\n *\n * @private\n */\n\nfunction ThreadGlobal() {\n  this.id = utils.uuid();\n  this.type = utils.env();\n  this.isRoot = isRoot();\n  this.manager = new BroadcastChannel('threadsmanager');\n  this.ports = [];\n  this.services = {};\n  this.connections = {\n    inbound: 0,\n    outbound: 0\n  };\n\n  this.messenger = new Messenger(this.id, '[ThreadGlobal]')\n    .handle('ping', this.onPing, this);\n\n  this.onmessage = this.onmessage.bind(this);\n  this.listen();\n  this.ready();\n\n  debug('initialized', this.id, this.type, this.isRoot);\n}\n\n/**\n * Listens for incoming messages.\n *\n * @private\n */\n\nThreadGlobal.prototype.listen = function() {\n  debug('listen');\n  switch (this.type) {\n    case 'sharedworker':\n      addEventListener('connect', function(e) {\n        debug('port connect');\n        var port = e.ports[0];\n        this.ports.push(port);\n        port.onmessage = this.onmessage;\n        port.start();\n      }.bind(this));\n    break;\n    case 'worker':\n    case 'window':\n      addEventListener('message', this.onmessage);\n  }\n};\n\n/**\n * Ping the outside world to let them\n * know the thread is ready.\n *\n * @private\n */\n\nThreadGlobal.prototype.ready = function() {\n  if (this.isRoot) return;\n  debug('ready', this.id);\n  this.messenger.push(this, {\n    type: 'threadready',\n    data: this.serialize()\n  });\n};\n\n/**\n * Respond when the outside world asks\n * if we're ready.\n *\n * @private\n */\n\nThreadGlobal.prototype.onPing = function(request) {\n  debug('on ping');\n  request.respond(this.serialize());\n};\n\n/**\n * Return serialized state.\n *\n * @return {Object}\n */\n\nThreadGlobal.prototype.serialize = function() {\n  return {\n    id: this.id,\n    services: this.services\n  };\n};\n\n/**\n * When a message is sent to this thread\n * we re-emit the message internally.\n *\n * The thread-global abstracts away the\n * the complexity of message listening\n * so that `Service` can just do:\n *\n *   thread.on('message', ...);\n *\n * and not care what thread type\n * it's running in.\n *\n * @param  {Event} e\n * @private\n */\n\nThreadGlobal.prototype.onmessage = function(e) {\n  debug('on message', e);\n  this.messenger.parse(e);\n  this.emit('message', e);\n};\n\n/**\n * Keeps a record of what services are\n * running inside this thread.\n *\n * This makes the assumption that\n *\n * TODO: If services are destroyed we\n * should remove it from this list.\n *\n * @param  {Service} service\n */\n\nThreadGlobal.prototype.serviceReady = function(service) {\n  debug('service ready', service);\n  if (this.services[service.name]) throw error(2, service.name);\n\n  this.services[service.name] = {\n    id: service.id,\n    name: service.name\n  };\n\n  this.messenger.push(this, {\n    type: 'serviceready',\n    data: this.services[service.name]\n  });\n};\n\n/**\n * Message the thread parent\n * (instanceof ChildThread) to\n * inform them of something that\n * has happened inside the thread.\n *\n * The Manager could have created\n * the `ChildThread` or it could\n * have been created manually by\n * the user.\n *\n * @param  {Message} message\n * @public\n */\n\nThreadGlobal.prototype.postMessage = function(message) {\n  debug('postMessage (%s)', this.type, message);\n  switch (this.type) {\n    case 'worker':\n      postMessage(message); break;\n    case 'sharedworker':\n      this.ports.forEach(function(port) { port.postMessage(message); });\n      break;\n    case 'window':\n      window.parent.postMessage(message, '*'); break;\n  }\n};\n\n/**\n * Increment the connection count.\n *\n * @param  {String} type  ['incoming','outgoing']\n */\n\nThreadGlobal.prototype.connection = function(type) {\n  if (!(type in this.connections)) throw error(1, type);\n  this.connections[type]++;\n  debug('connection', type, this.connections[type]);\n  this.check();\n};\n\n/**\n * Decrement the connection count.\n *\n * @param  {String} type  ['incoming','outgoing']\n */\n\nThreadGlobal.prototype.disconnection = function(type) {\n  if (!(type in this.connections)) throw error(1, type);\n  this.connections[type]--;\n  debug('disconnection', type, this.connections[type]);\n  this.check();\n};\n\n/**\n * Checks to see if the thread is\n * 'redundant', broadcasting an event\n * to notify the outside world if so.\n *\n * @private\n */\n\nThreadGlobal.prototype.check = function() {\n  if (this.isRedundant()) {\n    debug('redundant');\n    this.messenger.push(this, { type: 'redundant' });\n  }\n};\n\n/**\n * A thread is 'redundant' when it has\n * no clients and it's not a 'root'.\n *\n * @return {Boolean}\n */\n\nThreadGlobal.prototype.isRedundant = function() {\n  return !this.isRoot && this.isDetached();\n};\n\n/**\n * A thread is 'detached' when\n * it has no clients.\n *\n * @return {Boolean}\n */\n\nThreadGlobal.prototype.isDetached = function() {\n  return !this.connections.inbound;\n};\n\n/**\n * Utils\n */\n\n/**\n * Detects if current context\n * is the 'root' window.\n *\n * @return {Boolean}\n */\n\nfunction isRoot() {\n  return inWindow() && window.parent === window;\n}\n\n/**\n * Detects if current context\n * is runnign in a Window.\n *\n * @return {Boolean}\n */\n\nfunction inWindow() {\n  return typeof window !== 'undefined';\n}\n\n/**\n * Handy `Error` factory.\n *\n * @param  {Number} id\n * @return {String}\n */\n\nfunction error(id) {\n  var args = [].slice.call(arguments, 1);\n  return new Error({\n    1: 'Unknown connection type: \"' + args[0] + '\"',\n    2: 'Service \"' + args[0] + '\"already defined'\n  }[id]);\n}\n\n/**\n * Export `ThreadGlobal` singleton\n */\n\nmodule.exports = new ThreadGlobal();\n","'use strict';\n\n/**\n * Create a UUID string.\n *\n * @return {String}\n */\n\nexports.uuid = function (){\n  var timestamp = Date.now();\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(\n    /[xy]/g,\n    function onEachCharacter(c) {\n      var r = (timestamp + Math.random() * 16) % 16 | 0;\n      timestamp = Math.floor(timestamp / 16);\n      return (c == 'x' ? r : (r&0x7|0x8)).toString(16);\n    }\n  );\n};\n\n/**\n * Check that the given arguments\n * match the given types.\n *\n * Example:\n *\n *   typesMatch([1, 'foo'], ['number', 'string']) //=> true\n *   typesMatch([1, 'foo'], ['string', 'number']) //=> false\n *\n * @param  {Array} args\n * @param  {Array} types\n * @return {Boolean}\n */\n\nexports.typesMatch = function (args, types) {\n  for (var i = 0, l = args.length; i < l; i++) {\n    if (typeof args[i] !== types[i]) return false;\n  }\n\n  return true;\n};\n\n/**\n * Returns a Promise packaged\n * inside an object.\n *\n * This is convenient as we don't\n * have to have a load of callbacks\n * directly inside our funciton body.\n *\n * @return {Object}\n */\n\nexports.deferred = function () {\n  var deferred = {};\n  deferred.promise = new Promise(function(resolve, reject) {\n    deferred.resolve = resolve;\n    deferred.reject = reject;\n  });\n  return deferred;\n};\n\n/**\n * Parses a url query string and\n * spits out a key/value object.\n *\n * Example:\n *\n *   query('?foo=bar').foo; //=> 'bar'\n *   query('?foo=bar&baz=bat').baz; //=> 'bat'\n *\n * @param  {String} string\n * @return {Object}\n */\n\nexports.query = function(string) {\n  var result = {};\n\n  string\n    .replace('?', '')\n    .split('&')\n    .forEach(function(param) {\n      var parts = param.split('=');\n      result[parts[0]] = parts[1];\n    });\n\n  return result;\n};\n\n/**\n * Returns type of environment\n * the current script is running in.\n *\n * @return {String}\n */\n\nexports.env = function() {\n  return {\n    'Window': 'window',\n    'SharedWorkerGlobalScope': 'sharedworker',\n    'DedicatedWorkerGlobalScope': 'worker',\n    'ServiceWorkerGlobalScope': 'serviceworker'\n  }[self.constructor.name] || 'unknown';\n};\n"]}